#version 100

uniform mat4 projection_matrix;
uniform mat4 modelview_matrix;
uniform vec4 current_color;

// Lights
uniform bool lightsOn[8];
uniform vec4 lightsPos[8];

uniform vec3 lightsDiffuse[8];
uniform vec3 lightsAmbient[8];
uniform vec3 lightsSpecular[8];

uniform vec3 globalAmbient;
uniform bool lightingOn;

// Material
uniform bool perVertexColor;
uniform vec3 matDiffuse;
uniform vec3 matAmbient;
uniform vec3 matSpecular;
uniform vec3 matEmissive;
uniform float matOpacity;
uniform float matPower;
uniform bool matTwoSided;

// Fog
uniform bool fogOn;
uniform float fogDensity;
uniform vec3 fogColor;

/*
in vec2 texCoord;
in vec3 vertex;
in vec3 normal;
in vec4 color;

out vec2 fTexCoord;
out vec4 fColor;
out vec4 fColorBack;
*/

attribute vec2 texCoord;
attribute vec3 vertex;
attribute vec3 normal;
attribute vec4 color;

varying vec2 fTexCoord;
varying vec4 fColor;
varying vec4 fColorBack;

void main(void)
{
   float f = 1.0;
   vec3 n = normalize(mat3(modelview_matrix) * normal);
   vec4 pos = modelview_matrix * vec4(vertex, 1.0);

   gl_Position = projection_matrix * pos;
   fTexCoord = texCoord;

   if(fogOn)
      f = clamp(exp(fogDensity * pos.z), 0.0, 1.0);

   if(lightingOn)
   {
      vec3 diffuseColor = perVertexColor ? color.xyz : matDiffuse;
      vec3 ambientColor = perVertexColor ? color.xyz : matAmbient;
      float opacity = perVertexColor ? color.w : matOpacity;
      vec3 c = vec3(0);
      vec3 c2 = vec3(0);
      // vec3 ecPosition3 = vec3(gl_Position) / gl_Position.w;
      vec3 eye = vec3(0.0, 0.0, 1.0);

      fColor = vec4(0);
      if(matTwoSided)
         fColorBack = vec4(0);
      for(int i = 0; i < 8; i++)
         if(lightsOn[i])
         {
            vec4 l = lightsPos[i];
            float d = dot(n, l.xyz);
            float pf = 0.0;
            vec3 VP = l.xyz;
            vec3 halfVector;
            if(matPower != 0.0)
            {
               float nDotVP;
               VP = l.xyz;
               halfVector = normalize(VP + eye);
               nDotVP = max(0.0, dot(n, VP));
               if(nDotVP != 0.0)
               {
                  float nDotHV = max(0.0, dot(n, halfVector));
                  pf = pow(nDotHV, matPower);
               }
            }

            c += diffuseColor * min(1.0, max(0.0, d)) * lightsDiffuse[i];
            c += matSpecular * pf * lightsSpecular[i];
            c += matAmbient * lightsAmbient[i];

            if(matTwoSided)
            {
               vec3 iN = -n;
               float d2 = dot(iN, l.xyz);
               if(matPower != 0.0)
               {
                  float nDotVP = max(0.0, dot(iN, VP));
                  if(nDotVP != 0.0)
                  {
                     float nDotHV = max(0.0, dot(iN, halfVector));
                     pf = pow(nDotHV, matPower);
                  }
               }

               c2 += diffuseColor * min(1.0, max(0.0, d2)) * lightsDiffuse[i];
               c2 += matSpecular * pf * lightsSpecular[i];
               c2 += matAmbient * lightsAmbient[i];
            }
         }

      c += ambientColor * globalAmbient;
      c += matEmissive;
      fColor = vec4(c, opacity);

      if(fogOn)
         fColor = f * fColor + (1.0-f) * vec4(fogColor, 1);

      if(matTwoSided)
      {
         c2 += ambientColor * globalAmbient;
         c2 += matEmissive;
         fColorBack = vec4(c2, opacity);

         if(fogOn)
            fColorBack = f * fColorBack + (1.0-f) * vec4(fogColor, 1);
      }
   }
   else
   {
      fColor = current_color * (perVertexColor ? color : vec4(1,1,1,1));

      if(fogOn)
         fColor = f * fColor + (1.0-f) * vec4(fogColor, 1);
   }
}
